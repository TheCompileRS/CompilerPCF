# base
let rec suma  (x y: Nat) : Nat = ifz y then x else succ (suma x (pred y))
let rec resta (x y: Nat) : Nat = ifz y then x else pred (resta x (pred y))
let rec mult  (x y: Nat) : Nat = ifz y then 0 else suma (mult x (pred y)) x
let rec exp   (x y: Nat) : Nat = ifz y then 1 else mult (exp x (pred y)) x
let rec fact  (n: Nat)   : Nat = ifz n then 1 else mult n (fact (pred n))

# booleanos
type Bool = Nat
let true  : Bool = 1
let false : Bool = 0
let neg (b: Bool) : Bool = ifz b then true else false

# pares de naturales
let pairNat (x y b: Nat) : Nat = ifz b then x else y   
let fstNat (p: Nat -> Nat) : Nat = p false
let sndNat (p: Nat -> Nat) : Nat = p true

# R para naturales
let RNat (z: Nat) (s: Nat -> Nat -> Nat) : Nat -> Nat
    = fix (f: Nat -> Nat) (n: Nat) -> 
        ifz n then z else s (f (pred n)) (pred n)

# minimizador
let mu (f: Nat -> Nat) : Nat 
    = let rec try (n: Nat) : Nat = ifz f n then n else try (succ n)
      in try 0
